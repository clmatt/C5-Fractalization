-----Case_1_P.cpp-----

This program iterates through all possible 9 <= n <= 1000 in program P in case 1. It outputs which n it is on. If it finds a possible counterexample corresponding to a negative objective value it outputs the part sizes. Note that it does not take into account ordering (unlike in small.cpp), therefore it will only output (2,2,2,1,1) not also (2,2,1,2,1). 

To run: Nothing in the program needs to be changed. The program can be adjusted to run for a different range of n or a different tolerance by changing the global variables on lines 5, 6, and 7. The program can be compiled using the MakeFile and has executible Case_1_P.out


-----Case_1_P_negative.cpp-----

This is meant to be used in conjunction with Medium.cpp. Medium.cpp outputs possible counterexamples generated by program P in case 1. The program takes, as an input, these part sizes of the possible counter examples. The program iterates through all possible numbers of funky edges (which is bounded using Lemma 2.2) and outputs the maximum number of 5-cycles, as well as the number of 5 cycles in a balanced iterated blow up of a 5-cycle. Note that this program bounds the number of possible 5-cylces rather than giving an exact count, as edges within parts are considered an edge when it would create a 5-cycle, and not an edge if it would destroy a 5-cycle. 

To run: Go into the program and change the global variable n on line 13 to be the number of vertices, and x[1],x[2],x[3],x[4], and x[5] in lines 34 through 39. Note that x[1]+x[2]+x[3]+x[4]+x[5]=n. The order of the x[i]'s is important (2,2,1,2,1) is not the same as (2,2,2,1,1) because the first case doesn't have the two parts of size 1 adjacent to each other. The program can be compiled with the MakeFile and will have an executable Case_1_P_Negative.out.


-----Case_2.1_P_Prime.cpp-----

This program shows that program P' in case 2.1 has a non-negative objective function value. It uses a dynamic mesh to bound the objective function value on increasingly smaller grid sizes. If there were a negative objective function, the program would not terminate, but instead it would keep creating smaller grids centered on the negative objective function value. 

To run: Nothing in the program needs to be changed. The program can be adjusted to run for a different value of d, n, or a different tolerance by the global variables on lines 21, 26, or 29. The program can be compiled using the MakeFile and has executible Case_2.1_P_Prime.out.


-----Case_2.2_P_Double_Prime.cpp-----

This program shows that program P'' in case 2.2 has a non-negative objective function value. It uses a dynamic mesh to bound the objective function value on increasingly smaller grid sizes. If there were a negative objective function, the program would not terminate, but instead it would keep creating smaller grids centered on the negative objective function value. 

To run: Nothing in the program needs to be changed. The program can be adjusted to run for a different value of d, n, or a different tolerance by the global variables on lines 32, 33, or 38. The program can be compiled using the MakeFile and has executible Case_2.2_P_Double_Prime.out.

